# Problème de la récursion à gauche
* Un non-terminal qui peut dériver une phrase commencant par lui-même est
récursif gauche.
* Il y a deux sortes de récursion gauche, la récursion gauche immédiate
(ou directe) d’un non-terminal A apparaît lorsqu’une règle de A possède un
membre droit débutant par A.
* Un non-terminal récursif gauche qui n’est pas récursif gauche de façon
immédiate, l’est de façon indirect.

Bonne nouvelle : on peut toujours supprimer la récursion gauche,
c’est-à-dire transformer une grammaire possédant des non-terminaux
récursifs à gauche en une grammaire équivalente non récursive gauche.

### Élimination de la récursion directe
* Nous allons voir une méthode de suppression de la récursion immédiate à
gauche qui suppose que la grammaire considérée ne contient pas de règles de
la forme :
* « A &rarr; &epsilon; » : règle de production vide.
* « A &rarr; B » : règle unitaire.
où les symboles A et B sont des non-terminaux.

Heureusement, il est aussi possible de transformer toute grammaire avec de
telles règles en une grammaire équivalente sans règles unitaires ou de
production vide.

### Élimination des règles de production vide
* Soit une grammaire G contenant une règle de la forme :
A &rarr; &epsilon;
* Pour toute règle de la forme :
B → &alpha;A&beta;
* On peut rajouter la règle suivante dans la grammaire :
B → &alpha;&beta;
* On introduit alors un non-terminal A' avec les mêmes règles que A sauf
celles de production vide. On peut remplacer toutes les occurrences de A par A' dans les règles de la grammaire.

### Élimination des règles unitaires
* Soit une grammaire G possédant une règle :
A &rarr; B où A et B sont des non-terminaux.
* Supposons que B soit déﬁni ainsi :
B &rarr; &alpha;1 | &alpha;2 | . . . | &alpha;n
* On peut mettre en ligne la déﬁnition de B en rajoutant la règle :
A &rarr; &alpha;1 | &alpha;2 | . . . | &alpha;n

On peut retomber sur la règle « A &rarr; B ».
* Ce cas témoigne de la présence de dérivations inﬁnies.
* On peut, sans modiﬁer le langage, supprimer cette nouvelle occurrence de la
règle « A &rarr; B »



# Grammaires LL(1)

## Fonction FIRST
La déﬁnition précédente peut s’exprimer à l’aide de ces équations déﬁnissant
FIRST(&alpha;) où &alpha; est un mot de (T &cup; N)<sup>+</sup> :
FIRST(a&alpha;) = {a}
FIRST(A&alpha;) = FIRST(A)
FIRST(&alpha;) &sube; FIRST(A) Si A &rarr, &alpha; dans G


### Calcul de point ﬁxe
* Une solution aux systèmes d’inéquations précédent est fournit par le plus
petit point ﬁxe de la fonction suivante :
FIRST<sup>n</sup>(a&alpha;) = {a}
FIRST<sup>n</sup>(A&alpha;) = FIRST<sup>n-1</sup>(A)
FIRST<sup>n</sup>(A) = FIRST<sup></sup>{n−1}(A) &cup; FIRST<sup>n-1</sup>(&alpha;) Si A &rarr; &alpha; dans G
* Pour calculer ce plus petit point ﬁxe, on se donne une fonction FIRST<sup>0</sup> qui associe la fonction constante « w &rarr; &empty; ».
* On itère ensuite la déﬁnition de cette fonction pour calculer une nouvelle
fonction FIRST<sup>n</sup>. Cette fonction associe à tous les mots des ensembles plus grands que la fonction de l’itération précédente.
* Or, la taille de ces ensembles est bornée par le cardinal de l’alphabet (ﬁni)
des non-terminaux.
&rArr; Cette itération termine donc et est une solution du système d’inéquations.

### Conﬂit FIRST/FIRST
* Si les ensembles FIRST de deux règles d’un non-terminal partage un
symbole, on dit que l’on a un conﬂit FIRST/FIRST.
* Une telle grammaire n’est donc pas LL(1).


### Traitement des non-terminaux produisant le mot vide
* Face à une règle de la forme A &rarr; &epsilon;, on ne peut pas décider quels terminaux peuvent suivre A.
* Il faut aller voir les terminaux qui peuvent suivre A en observant les règles
qui utilisent A.
* Pour eﬀectuer cette inspection eﬃcacement, on étend le co-domaine de la
fonction FIRST : on rajoute un nouveau symbole &epsilon; à l’ensemble des terminaux.
* Si &epsilon; &isin; FIRST(A), cela signiﬁe que le non terminal A peut produire le mot vide. On dit qu’il est annulable.

* On modiﬁe aussi la déﬁnition de FIRST :
FIRST(&epsilon;) = { &epsilon; }  
FIRST(a&alpha;) = {a}  
FIRST(A&alpha;) = FIRST(A) Si &epsilon; &isin; FIRST(A)
FIRST(A&alpha;) = (FIRST(A) \ { &epsilon; }) &cup; FIRST(&alpha;) Si &epsilon; &isin; FIRST(A)
FIRST(&alpha;) &sube; FIRST(A) Si A &rarr; &alpha; dans G

### Un premier algorithme
* À l’aide de cette nouvelle version de la fonction FIRST, on peut déﬁnir un
algorithme d’analyse syntaxique qui utilise la grammaire.
* À chaque étape de prédiction, si &alpha; est la prédiction courante, on calcule FIRST(&alpha;) pour déterminer la règle de la grammaire à utiliser.
* Si il y a plusieurs règles, on échoue : la grammaire n’est pas LL(1).

### Défauts de l’algorithme

## Déﬁnition de la fonction FOLLOW
* On utilise une déﬁnition similaire à FIRST à l’aide d’inéquations :  
FIRST(&beta;) &sube; FOLLOW (A) Si B &rarr; &alpha;A&beta; dans G  
FOLLOW (B) &sube; FOLLOW (A) Si B &rarr; &alpha;A&beta; dans G et &epsilon; ∈ FIRST(&beta;)	
* On peut encore résoudre ce système par itération du système récursif :
FOLLOW<sup>n</sup>(A) = FOLLOW<sup>n-1</sup>(A) &cup; FIRST(&beta;) Si B &rarr; &alpha;A&beta; dans G  
FOLLOW<sup>n</sup>(A) = FOLLOW<sup>n-1</sup>(B) &cup; FOLLOW<sup>n-1</sup>(A) Si B &rarr; &alpha;A&beta; dans G et &epsilon; &isin; FIRST(&beta;).
# Logique de premier ordre (suite)
Pré-condition : parfois nécessaire pour assurer la relation entrée-sortie.

# Tri : Seq[E] -> Seq[E]}
## Spécification
&forall; s, s' &isin; Seq[E]  
Tri(s) = s' &hArr; Ord(s') &and; MutliEns(s) = MultiEns(s')

## Implémentation 1
Tri ([]) =  []  
Tri(a.S) = soit t = Tri(S) dans Insertion(a, t)

## Preuve de correction 1
Pas besoin de prouver la correction de l'implémentation de `Insertion` pour prouver la correction de `Tri`. On part du principe que `Insertion` satisfait les spécifications vues plus tôt.  
Du coup, la preuve de correction de `Tri` sera valable pour n'importe quelle implémentation de `Insertion` !

* Cas de base : Tri([]) = [], Ord([]), MultiEns([]) = MultiEns([])
* Pas d'induction :
  * On suppose l'appel t = Tri(s) correct et donc Ord(t) et MultiEns(t) = MultiEns(s)
  * Ord(t) &rArr; (t' = Inserer(a, t) &hArr; Ord(t') &and; MultiEns(t') = MultiEns(t) &cup; {a}))

## Implémentation 2
Tri([]) = []  
Tri(a.s) = soit (e, t) = ExtMin(a.s) dans soit t' = Tri(t) dans (e.t')

ExtMin : Seq[E] -> E x Seq[E]  
&forall; s, s' &isin; Seq[E], &forall; e &isin; E  
s &ne; [] &rArr; (ExtMin(s = (e, s') &hArr; &forall; e' &isin; MultiEns(s), e &le; e' &and; e &isin; MultiEns(s) &and; MultiEns(s) = MultiEns(s') &cup; {e})

## Preuve 2
* Cas de base : Tri([]) = [] (idem Preuve 1)
* Pas d'induction : 
  * On suppose l'appel (e, t) = ExtMin(a.s) correct.
  * HI (Induction neuterienne) : e.Tri(t) correct.
  * On a :
     * (1) &forall; e' &isin; MultiEns(a.s) e &le; e', e &isin; MultiEns(a.s) 
     * (2) MultiEns(a.s) = MultiEns(t) &cup; {e}
     * (3) Ord(t') &and; MultiEns(t) = MultiEns(t')
